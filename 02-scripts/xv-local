#!/usr/bin/env bash

# Ensure we are in the git root
cd "$(git rev-parse --show-toplevel)" || exit 1

# Timestamp for report directory
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
REPORT_DIR="ai-ensemble/reports/${TIMESTAMP}"
mkdir -p "$REPORT_DIR"

# Determine context (Staged diff or specific file)
CONTEXT_ARG="$1"
DIFF_CONTENT=""
TARGET_FILE=""

if [[ "$CONTEXT_ARG" == *"파일"* && "$CONTEXT_ARG" == *"리뷰"* ]]; then
    # Extract filename from argument like "파일 src/main.py 리뷰"
    # Assuming format: "파일 <filepath> 리뷰"
    TARGET_FILE=$(echo "$CONTEXT_ARG" | sed -E 's/파일 (.*) 리뷰/\1/')
    if [ -f "$TARGET_FILE" ]; then
        echo "Validating specific file: $TARGET_FILE"
        DIFF_CONTENT=$(cat "$TARGET_FILE")
    else
        echo "Error: File $TARGET_FILE not found."
        exit 1
    fi
else
    # Default to staged diff, fallback to working tree diff
    echo "Validating staged changes..."
    if git diff --cached --quiet; then
        echo "No staged changes found. Checking working tree..."
        DIFF_CONTENT=$(git diff)
    else
        DIFF_CONTENT=$(git diff --cached)
    fi
    
    if [ -z "$DIFF_CONTENT" ]; then
        echo "No changes to validate."
        exit 0
    fi
fi


# Prepare prompt content
# 우선순위: 1) 프로젝트 커스텀 프롬프트 → 2) 시스템 프롬프트 원본에서 복사
PROMPT_TEMPLATE="ai-ensemble/custom-prompts/review.md"
SYSTEM_PROMPT="01-system-prompts/default_review.md"

if [ ! -f "$PROMPT_TEMPLATE" ]; then
    mkdir -p "$(dirname "$PROMPT_TEMPLATE")"
    if [ -f "$SYSTEM_PROMPT" ]; then
        cp "$SYSTEM_PROMPT" "$PROMPT_TEMPLATE"
        echo "커스텀 프롬프트 생성: $SYSTEM_PROMPT → $PROMPT_TEMPLATE"
    else
        echo "Error: 시스템 프롬프트를 찾을 수 없습니다: $SYSTEM_PROMPT"
        echo "install.sh를 먼저 실행해주세요."
        exit 1
    fi
fi

PROMPT_FILE="${REPORT_DIR}/prompt.txt"

# Read template and replace placeholders manually (safe for large content)
# We use perl for safer multi-line replacement if available, or simple sed
# But simplest bash way for large content is to build the file:

# 1. Read template up to {{CONTEXT_ARG}}
# 2. Insert Context
# 3. Read template up to {{DIFF_CONTENT}}
# 4. Insert Diff
# 5. Read rest

# Simple sed approach (might fail on special chars in context/diff with complex escaping)
# Better approach: Construct the prompt file directly using variables
# We will use the template file as a reference but for robustness in bash, we'll reconstruct it with variables here
# unless we implement a proper template engine.
# However, to support user editing the template, we must respect the template file content.

# Let's use a simple python oneliner if available, or just cat for now
export CONTEXT_ARG DIFF_CONTENT
if command -v python3 &> /dev/null; then
    python3 -c "
import sys
import os

template_path = '$PROMPT_TEMPLATE'
context_arg = os.environ.get('CONTEXT_ARG', '')
diff_content = os.environ.get('DIFF_CONTENT', '')

try:
    with open(template_path, 'r') as f:
        template = f.read()
    
    # Simple replacement
    output = template.replace('{{CONTEXT_ARG}}', context_arg).replace('{{DIFF_CONTENT}}', diff_content)
    
    with open('$PROMPT_FILE', 'w') as f:
        f.write(output)
except Exception as e:
    sys.exit(1)
"
    # If python failed (e.g. file not found), fallback to cat
    if [ $? -ne 0 ]; then
        echo "Error utilizing python for template. Using fallback."
        cat <<EOF > "$PROMPT_FILE"
Review Context: $CONTEXT_ARG
Code:
$DIFF_CONTENT
EOF
    fi
else
    # Fallback if no python
    cat <<EOF > "$PROMPT_FILE"
Review Context: $CONTEXT_ARG
Code:
$DIFF_CONTENT
EOF
fi

echo "Prompt generated at $PROMPT_FILE"

# Calculate Prompt Hash for Traceability
if command -v shasum &> /dev/null; then
    PROMPT_HASH=$(shasum -a 256 "$PROMPT_FILE" | awk '{print $1}')
elif command -v sha256sum &> /dev/null; then
    PROMPT_HASH=$(sha256sum "$PROMPT_FILE" | awk '{print $1}')
else
    PROMPT_HASH=$(md5 -q "$PROMPT_FILE") # macOS fallback
fi

# Run Claude and Codex in parallel
echo "Running Claude and Codex..."

# Claude execution (assuming claude -p acceptable)
# Since the prompt might be large, we'll cat it into a variable or pass via file if supported.
# CLI typically accepts prompt string.
PROMPT_CONTENT=$(cat "$PROMPT_FILE")

# Unset CLAUDECODE to allow running Claude from within Claude Code sessions
(unset CLAUDECODE; claude -p "$PROMPT_CONTENT" > "${REPORT_DIR}/claude.txt" 2>/dev/null) &
CLAUDE_PID=$!

# Codex execution
(echo "$PROMPT_CONTENT" | codex exec - > "${REPORT_DIR}/codex.txt" 2>/dev/null) &
CODEX_PID=$!

# Gemini execution
(echo "$PROMPT_CONTENT" | gemini -o text > "${REPORT_DIR}/gemini.txt" 2>/dev/null) &
GEMINI_PID=$!

wait $CLAUDE_PID
wait $CODEX_PID
wait $GEMINI_PID

# Check for failures by verifying output files have content
WARNINGS=""

if [ ! -s "${REPORT_DIR}/claude.txt" ]; then
    WARNINGS="${WARNINGS}\n- Claude: no response"
fi
if [ ! -s "${REPORT_DIR}/codex.txt" ]; then
    WARNINGS="${WARNINGS}\n- Codex: no response"
fi
if [ ! -s "${REPORT_DIR}/gemini.txt" ]; then
    WARNINGS="${WARNINGS}\n- Gemini: no response"
fi

# Run Validators if environment variables are set
VALIDATOR_FAIL=0
if [ -n "$LINT_CMD" ]; then
    echo "Running Lint: $LINT_CMD"
    eval "$LINT_CMD" || VALIDATOR_FAIL=1
fi
if [ -n "$TYPECHECK_CMD" ]; then
    echo "Running Typecheck: $TYPECHECK_CMD"
    eval "$TYPECHECK_CMD" || VALIDATOR_FAIL=1
fi
if [ -n "$TEST_CMD" ]; then
    echo "Running Tests: $TEST_CMD"
    eval "$TEST_CMD" || VALIDATOR_FAIL=1
fi

if [ $VALIDATOR_FAIL -ne 0 ]; then
    echo "Validator failed."
    exit 1
fi

# Generate Report MD
REPORT_MD="${REPORT_DIR}/report.md"
cat <<EOF > "$REPORT_MD"
# AI Code Review Report
**Date:** $(date)
**Context:** $CONTEXT_ARG
**Prompt Hash:** \`$PROMPT_HASH\`

## Status
$WARNINGS

## Claude Response
$(cat "${REPORT_DIR}/claude.txt" 2>/dev/null || echo "No output")

---

## Codex Response
$(cat "${REPORT_DIR}/codex.txt" 2>/dev/null || echo "No output")

---

## Gemini Response
$(cat "${REPORT_DIR}/gemini.txt" 2>/dev/null || echo "No output")
EOF

echo "Report generated: $REPORT_MD"

# Automatically open the report in the user's editor
if command -v antigravity &> /dev/null; then
    antigravity "$REPORT_MD"
elif command -v code &> /dev/null; then
    code "$REPORT_MD"
else
    open "$REPORT_MD"
fi

exit 0
