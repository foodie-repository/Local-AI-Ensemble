#!/usr/bin/env bash
set -euo pipefail

# Ensure we are in the git root
cd "$(git rev-parse --show-toplevel)" || exit 1

# 공통 함수 로드
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
source "${SCRIPT_DIR}/xv-common"

# Timestamp for report directory
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
REPORT_DIR="ai-ensemble/reports/${TIMESTAMP}"
mkdir -p "$REPORT_DIR"

# Determine context (Staged diff or specific file)
CONTEXT_ARG="${1:-}"
DIFF_CONTENT=""
TARGET_FILE=""

if [[ "$CONTEXT_ARG" == *"파일"* && "$CONTEXT_ARG" == *"리뷰"* ]]; then
    # "파일 <filepath> 리뷰" 형식에서 파일 경로 추출
    TARGET_FILE=$(echo "$CONTEXT_ARG" | sed -E 's/파일 (.*) 리뷰/\1/')
    if [ -f "$TARGET_FILE" ]; then
        echo "파일 검증 중: $TARGET_FILE"
        DIFF_CONTENT=$(cat "$TARGET_FILE")
    else
        echo "Error: 파일을 찾을 수 없습니다: $TARGET_FILE"
        exit 1
    fi
else
    # Staged 변경사항 검증, 없으면 Working tree 검증
    echo "Staged 변경사항 검증 중..."
    if git diff --cached --quiet; then
        echo "Staged 변경사항 없음. Working tree 확인 중..."
        DIFF_CONTENT=$(git diff)
    else
        DIFF_CONTENT=$(git diff --cached)
    fi
    
    if [ -z "$DIFF_CONTENT" ]; then
        echo "검증할 변경사항이 없습니다."
        exit 0
    fi
fi


# Prepare prompt content
# 우선순위: 1) 프로젝트 커스텀 → 2) Git 루트 원본 → 3) 설치된 프롬프트
PROMPT_TEMPLATE="ai-ensemble/custom-prompts/review.md"
SYSTEM_PROMPT="01-system-prompts/default_review.md"

load_prompt_template "$PROMPT_TEMPLATE" "$SYSTEM_PROMPT" || exit 1

PROMPT_FILE="${REPORT_DIR}/prompt.txt"

# 플레이스홀더 치환 (python3 사용, 없으면 fallback)
export CONTEXT_ARG DIFF_CONTENT
if command -v python3 &> /dev/null; then
    if python3 -c "
import sys
import os

template_path = '$PROMPT_TEMPLATE'
context_arg = os.environ.get('CONTEXT_ARG', '')
diff_content = os.environ.get('DIFF_CONTENT', '')

try:
    with open(template_path, 'r') as f:
        template = f.read()

    # Simple replacement
    output = template.replace('{{CONTEXT_ARG}}', context_arg).replace('{{DIFF_CONTENT}}', diff_content)

    with open('$PROMPT_FILE', 'w') as f:
        f.write(output)
except Exception as e:
    sys.exit(1)
"; then
        : # 템플릿 처리 성공
    else
        echo "템플릿 처리 실패. 기본 형식으로 생성합니다."
        cat <<EOF > "$PROMPT_FILE"
리뷰 컨텍스트: $CONTEXT_ARG
코드:
$DIFF_CONTENT
EOF
    fi
else
    cat <<EOF > "$PROMPT_FILE"
리뷰 컨텍스트: $CONTEXT_ARG
코드:
$DIFF_CONTENT
EOF
fi

echo "프롬프트 생성 완료: $PROMPT_FILE"

# Calculate Prompt Hash for Traceability
if command -v shasum &> /dev/null; then
    PROMPT_HASH=$(shasum -a 256 "$PROMPT_FILE" | awk '{print $1}')
elif command -v sha256sum &> /dev/null; then
    PROMPT_HASH=$(sha256sum "$PROMPT_FILE" | awk '{print $1}')
else
    PROMPT_HASH=$(md5 -q "$PROMPT_FILE") # macOS fallback
fi

# 모델 버전 감지
CLAUDE_MODEL=$(get_model_info claude)
CODEX_MODEL=$(get_model_info codex)
GEMINI_MODEL=$(get_model_info gemini)

# 타임아웃 명령 감지
TIMEOUT_CMD=$(get_timeout_cmd)

# Claude, Codex, Gemini 병렬 실행
echo "${CLAUDE_MODEL}, ${CODEX_MODEL}, ${GEMINI_MODEL} 실행 중..."

(unset CLAUDECODE; ${TIMEOUT_CMD} claude -p - < "$PROMPT_FILE" > "${REPORT_DIR}/claude.txt" 2>"${REPORT_DIR}/claude.err") &
CLAUDE_PID=$!

(${TIMEOUT_CMD} codex exec - < "$PROMPT_FILE" > "${REPORT_DIR}/codex.txt" 2>"${REPORT_DIR}/codex.err") &
CODEX_PID=$!

(${TIMEOUT_CMD} gemini -o text < "$PROMPT_FILE" > "${REPORT_DIR}/gemini.txt" 2>"${REPORT_DIR}/gemini.err") &
GEMINI_PID=$!

FAIL_COUNT=0

wait $CLAUDE_PID || true
wait $CODEX_PID || true
wait $GEMINI_PID || true

# 응답 검증
WARNINGS=""

if [ ! -s "${REPORT_DIR}/claude.txt" ]; then
    WARNINGS="${WARNINGS}
- Claude: 응답 없음"
    FAIL_COUNT=$((FAIL_COUNT + 1))
fi
if [ ! -s "${REPORT_DIR}/codex.txt" ]; then
    WARNINGS="${WARNINGS}
- Codex: 응답 없음"
    FAIL_COUNT=$((FAIL_COUNT + 1))
fi
if [ ! -s "${REPORT_DIR}/gemini.txt" ]; then
    WARNINGS="${WARNINGS}
- Gemini: 응답 없음"
    FAIL_COUNT=$((FAIL_COUNT + 1))
fi

# 3개 모두 실패 시 종료
if [ $FAIL_COUNT -eq 3 ]; then
    echo "Error: 모든 AI 모델이 응답하지 않았습니다."
    exit 1
fi

# Validator 실행 (환경변수가 설정된 경우)
# 보안: eval 대신 bash -c로 서브셸에서 실행하여 현재 셸 영향 차단
VALIDATOR_FAIL=0
if [ -n "${LINT_CMD:-}" ]; then
    echo "Lint 실행: $LINT_CMD"
    bash -c "$LINT_CMD" || VALIDATOR_FAIL=1
fi
if [ -n "${TYPECHECK_CMD:-}" ]; then
    echo "타입체크 실행: $TYPECHECK_CMD"
    bash -c "$TYPECHECK_CMD" || VALIDATOR_FAIL=1
fi
if [ -n "${TEST_CMD:-}" ]; then
    echo "테스트 실행: $TEST_CMD"
    bash -c "$TEST_CMD" || VALIDATOR_FAIL=1
fi

if [ $VALIDATOR_FAIL -ne 0 ]; then
    echo "Validator 실패."
    exit 1
fi

# 리포트 생성
REPORT_MD="${REPORT_DIR}/report.md"
cat <<EOF > "$REPORT_MD"
# AI 코드 리뷰 리포트
**날짜:** $(date)
**컨텍스트:** $CONTEXT_ARG
**프롬프트 해시:** \`$PROMPT_HASH\`

## 상태
$WARNINGS

## ${CLAUDE_MODEL} 응답
$(cat "${REPORT_DIR}/claude.txt" 2>/dev/null || echo "출력 없음")

---

## ${CODEX_MODEL} 응답
$(cat "${REPORT_DIR}/codex.txt" 2>/dev/null || echo "출력 없음")

---

## ${GEMINI_MODEL} 응답
$(cat "${REPORT_DIR}/gemini.txt" 2>/dev/null || echo "출력 없음")
EOF

echo "리포트 생성 완료: $REPORT_MD"

# 에디터에서 리포트 열기
open_in_editor "$REPORT_MD"

exit 0
